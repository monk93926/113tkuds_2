import java.util.Stack;

class Solution {
    /**
     * 解題邏輯與思路：
     *
     * 本題要求找出給定字串 `s` 中最長的「有效括號」子字串的長度。
     * 有效括號串是指括號能夠正確配對的字串，例如 "()", "(())", "()()"。
     *
     * 我們可以使用「堆疊」(Stack) 來解決這個問題。
     *
     * 1. **堆疊初始化**：
     * - 初始化一個堆疊，並預先壓入一個 `-1`。這個 `-1` 作為一個哨兵（sentinel）元素，
     * 它標誌著當前有效括號串的起始位置的「前一個」位置。
     * - 如果堆疊中只有一個元素，且這個元素是 `-1`，則當前字串中的括號是無效的。
     *
     * 2. **遍歷字串**：
     * - 遍歷字串 `s` 中的每個字符。
     * - **遇到左括號 '('**：將當前索引 `i` 壓入堆疊。這表示我們遇到了一個潛在的開頭。
     * - **遇到右括號 ')'**：
     * - 彈出堆疊頂部的元素。
     * - **如果堆疊為空**：這表示當前的右括號沒有匹配的左括號。
     * 將當前索引 `i` 壓入堆疊，作為下一個有效子字串的起始標記。
     * - **如果堆疊不為空**：表示我們找到了一對匹配的括號。
     * 當前有效括號的長度為 `i - stack.peek()`（當前索引減去堆疊頂部的索引）。
     * 更新 `maxLength` 為當前找到的最大長度。
     *
     * 3. **更新最大長度**：
     * - 在每次成功匹配後，計算當前有效括號串的長度，並更新 `maxLength`。
     *
     * 4. **返回結果**：
     * - 遍歷結束後，`maxLength` 就是最長有效括號子字串的長度。
     *
     * **時間複雜度**：O(n)，其中 n 是字串 `s` 的長度。我們只需要遍歷字串一次。
     * **空間複雜度**：O(n)，在最壞情況下（例如全為左括號），堆疊需要存儲 n 個索引。
     */
    public int longestValidParentheses(String s) {
        int maxLength = 0;
        Stack<Integer> stack = new Stack<>();
        // 預先壓入 -1 作為哨兵，標誌有效子串的起點
        stack.push(-1); 

        for (int i = 0; i < s.length(); i++) {
            char currentChar = s.charAt(i);
            
            if (currentChar == '(') {
                // 遇到左括號，壓入當前索引
                stack.push(i);
            } else { // currentChar == ')'
                // 遇到右括號，彈出堆疊頂部元素
                stack.pop();
                
                if (stack.isEmpty()) {
                    // 如果堆疊為空，表示當前右括號無效，將其索引壓入作為新的起始標記
                    stack.push(i);
                } else {
                    // 如果堆疊不為空，計算當前有效子串長度，並更新最大長度
                    // 當前有效長度 = 當前索引 - 堆疊頂部元素的索引
                    maxLength = Math.max(maxLength, i - stack.peek());
                }
            }
        }
        
        return maxLength;
    }
}